<!DOCTYPE html>
<html>
<head>
  <title>PRNG Cyberexperiment - Exercise 1: LFSR</title>
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/lfsr.css">
  <link rel="stylesheet" href="css/shift-register.css">
  <link rel="stylesheet" href="css/feedback-shift-register.css">
  <script src="js/jquery-3.0.0.min.js"></script>
  <script src="js/d3.v4.min.js"></script>

  <script type="text/javascript" src="js/inputs-noise-plot.js"></script>
  <script type="text/javascript" src="js/cycle-counter.js"></script>
  <script src="js/shift-register.js"></script>
  <script src="js/feedback-shift-register.js"></script>
  <script src="js/lfsr.js"></script>
  <script src="js/lfsr-headless.js"></script>
  <script>
  var shift_registers = [],
      shift_register_bits_with_arrows,
      feedback_shift_register
  jQuery(document).ready(function () {
    d3.selectAll(".shift-register").select(function () {
      var $this = $(this)
      var bit_width = parseInt($this.attr("data-bit-width"))
      var bits_with_arrows = !!$this.attr("data-bits-with-arrows")
      var in_out_with_values = !!$this.attr("data-in-out-with-values")
      var play = !!$this.attr("data-play")
      var shift_register_i = new ShiftRegister(this, bit_width, bits_with_arrows, in_out_with_values)
      if (play) {
        setInterval(function () {
          shift_register_i.tick()
        }, 1000)
      }
      shift_registers.push(shift_register_i)
    })
    d3.select(".feedback-shift-register").select(function () {
      var $this = $(this)
      var bit_width = parseInt($this.attr("data-bit-width"))
      feedback_shift_register = new FeedbackShiftRegister(this, bit_width)
      setInterval(function () {
        feedback_shift_register.tick()
      }, 1000)
    })
  })

  var bit_width, lfsr_headless, lfsr, noise_plot, cycle_counter
  jQuery(document).ready(function () {

    d3.select(".lfsr").select(function () {
      bit_width = parseInt($(this).attr("data-bit-width"))
      lfsr_headless = new LFSRHeadless(bit_width)
      noise_plot = new InputsNoisePlot($(".inputs-noise-plot").attr("id"), bit_width)
      cycle_counter = new CycleCounter()

      lfsr = new LFSR(this, bit_width, function (lfsr) {
        $(".lfsr-feedback-polynomial").html(lfsr.polynomialHtml())

        $(".lfsr-cycle-length").html("???")
        lfsr_headless.bits = JSON.parse(JSON.stringify(lfsr.bits))
        setTimeout(function () {
          cycle_counter.reset()
          var had_cycle_length = false
          for (var i = 0; i < noise_plot.numberCapacity; i++) {
            var lfsr_state2 = lfsr_headless.state()
            noise_plot.drawNumber(lfsr_state2)
            if (!had_cycle_length) {
              var cycle_length = cycle_counter.countValue(lfsr_state2)
              if (cycle_length) {
                $(".lfsr-cycle-length").html(cycle_length)
                console.log("cycle length: " + cycle_length)
                cycle_counter.reset()
                had_cycle_length = true
              }
            }
            lfsr_headless.tick()
          }
        }, 0)
      })
      $(".lfsr-feedback-polynomial").html(lfsr.polynomialHtml())

      setInterval(function() {
        var lfsr_state = lfsr.state()
        console.log(lfsr_state)
        lfsr.tick()
      }, 300)
    })
  })
  </script>
</head>
<body>
  <div class="container">
    <h1>PRNG Cyberexperiment - Exercise 1: LFSR</h1>
    <p><b>To learn more about Pseudo-random Number Generation, we're going to take a look at a relatively simple algorithm for it.</b></p>
    <hr>

    <h2>Flip flops</h2>
    <p>A flip flop is a memory element that stores 1 bit of information. A single True/False, 0/1 value. A single one can be useful as a boolean, or we can use several of them to store things like 32-bit integers.</p>

    <div class="shift-register" data-bit-width="1" data-bits-with-arrows="true" data-in-out-with-values="true" data-play="true" style="width: 260px; height: 70px;"></div>
    <p>In this exercise we'll use a chain of flipflops to create a low-quality Pseudo-Random Number Generator. To begin with, let's consider the flip flop above. It has an atomic <b>Step Operation</b> that works like this:</p>
    <ul>
      <li>The flip-flop current value is emitted on the <code>out</code> channel.</li>
      <li>The flip-flop takes a new value from the <code>in</code> channel.</li>
      <li>As it is an atomic operation, these happen simultaneously.</li>
    </ul>
    <p>We can depict this much more tersely:</p>
<pre><b>Atomic Step Operation</b>
flipflop &rarr; out
in &rarr; flipflop</pre>

    <h2>Shift Registers</h2>
    <p>Now let's consider several of these flipflops chained together. Each step, each flipflop emits the current value and takes a new one. As shorthand we tend to omit the arrows between sequences of flipflops.</p>
    <div class="shift-register" data-bit-width="8" data-in-out-with-values="true" data-play="true" style="width: 680px; height: 70px;"></div>

    <p>If you've done hardware you might recognise this as a Shift Register. If not, think of it as a fixed-size buffer for bits. Each <b>step operation</b>, 1 bit goes <code>out</code> on the right and 1 bit goes <code>in</code> on the left.</p>

    <p>The bit movements here can be expressed as:</p>
<pre><b>Atomic Step Operation</b>
flipflop<sub>8</sub> &rarr; out
flipflop<sub>n &lt; 8</sub> &rarr; flipflop<sub>n+1</sub>
in &rarr; flipflop<sub>1</sub></pre>

    <p>The input bits can come from anywhere &amp; output bits can go anywhere. This is merely a component in a system. These are commonly used for converting between serial and parallel interfaces.</p>
    <hr>

    <h2>Feeding back the output to input</h2>
    <p>Consider what would happen if in the example above we connected the <code>output</code> to <code>input</code>. This has become a ring buffer.</p>
    <button>Step &#9654;</button>
    <div class="feedback-shift-register" data-bit-width="8" style="width: 600px; height: 90px;"></div>
<pre><b>Atomic Step Operation</b>
flipflop<sub>8</sub> &rarr; feedback
flipflop<sub>n &lt; 8</sub> &rarr; flipflop<sub>n+1</sub>
feedback &rarr; flipflop<sub>1</sub></pre>
    <p>However this expression is becoming quite unwieldy. Instead we can express the feedback as a polynomial on GF(2). We represent feedback as a summation of terms, where <code>x<sup>n</sup></code> represents the <code>n</code>th bit. The feedback, being a single bit, is then <code>modulo 2</code> this polynomial. This is equivalent to the <code>XOR</code> expression.</p>
<pre>x<sup>8</sup></pre>

    <p>Now let's see how to make a PRNG out of this.</p>
    <hr>

    <h2>Linear Feedback Shift Register</h2>
    <p>In the example above we connected <code>output</code> to <code>input</code>, passing bits unmodified around again and again. The difference with a LFSR is that we apply a linear function to the internal state, i.e. <code>f(register) -> input</code>.</p>
    <table>
      <thead>
        <tr>
          <th colspan="3">XOR Truth Table</th>
        </tr>
        <tr>
          <th style="font-size: 24px;">&oplus;</th>
          <th>0</th>
          <th>1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td style="text-align: center;">0</td>
          <td style="text-align: center;">1</td>
        </tr>
        <tr>
          <th>1</th>
          <td style="text-align: center;">1</td>
          <td style="text-align: center;">0</td>
        </tr>
      </tbody>
    </table>
    <p><code>XOR</code> (denoted <code>&oplus;</code>) operations can be used to construct any linear function. We use <code>&oplus;</code> to combine several bits from the register into one input bit. Choosing that linear function is tricky.</p>
    <p>Choosing which bits to tap for this function is an important parameter for a LFSR. Get it wrong and you might find your game spawns enemies in only 1 or 2 different locations instead of anywhere on the map.</p>
    <p>If you consider the below with the state <code>0x11011000010110</code>, then for the same tap set it will always produce a particular next state. If you choose the tap bits badly you might find that this new state is the same state, or that the next one is. This is called the cycle length: the number of outputs before the generator produces the same output. For well chosen taps and a state of <code>b bits</code>, the cycle length can be <code>2<sup>b</sup></code>. But it could also be 1 or 2.</p>

<pre><b>Atomic Step Operation</b>
bit<sub>max</sub> &rarr; feedback
bit<sub>n &isin; taps</sub> &oplus; feedback &rarr; feedback
bit<sub>n &lt; max</sub> &rarr; bit<sub>n+1</sub>
feedback &rarr; bit<sub>1</sub></pre>

    <br>
    <p><b>Your objective: get to a cycle length of 16,383.</b> Toggle the tickboxes to control which bits are XORed ("tapped") and see how it affects the cycle length and visible patterns in the noise plot.</p>
    <div class="lfsr" data-bit-width="14" style="width: 905px; height: 180px;"></div>
    <p>Cycle length: <code class="lfsr-cycle-length">???</code></p>
    <p>Feedback polynomial: <code class="lfsr-feedback-polynomial"></code></p>
    <canvas class="inputs-noise-plot" id="inputs-noise-lcg" width="300" height="225" data-plot-name="LFSR Noise Plot"></canvas>
    <!--<canvas class="inputs-noise-coord-plot" id="inputs-noise-coord-lcg" width="300" height="325" data-plot-name="LFSR Coordinate Plot"></canvas>-->
    <hr>
  </div>
</body>
</html>
