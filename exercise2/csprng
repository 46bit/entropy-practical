#!/usr/bin/env python

# PYTHONPATH=$PYTHONPATH:$PWD/Tyche:$PWD/prng-exercise ./csprng

import sys, random, time, socket, struct, threading, exercise2
# @TODO: ensure PyCrypto installed?

class NumberServerThread(threading.Thread):
  def __init__(self, csprng_wrapper):
    threading.Thread.__init__(self)
    self.csprng_wrapper = csprng_wrapper

  def run(self):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("127.0.0.1", 4646))
    s.listen(5)
    try:
      while True:
        client, address = s.accept()
        sys.stdout.write("Client={}".format(address))
        sys.stdout.flush()
        self.serve_client(client)
    finally:
      s.shutdown(1)
      s.close()

  def serve_client(self, client):
    csprng_current_value = self.csprng_wrapper.get_current_value()
    csprng_tick_count = self.csprng_wrapper.tick_count

    # Only send any data before closing if the current value is unused.
    try:
      if csprng_current_value is not False:
        packer = struct.Struct('I I')
        packed_data = packer.pack(csprng_current_value, csprng_tick_count)
        client.sendall(packed_data)
    finally:
      client.close()

demo_start_time_backdating = random.randint(0xff, 0xff*2)
start_time = int(time.time()) - demo_start_time_backdating
seed = start_time
print "seed = %s" % seed

csprng = exercise2.CsprngSingleAccess(seed, write_dots=True)
csprng.advance(demo_start_time_backdating)

tick_thread = exercise2.TickThread(csprng.tick, 1)
tick_thread.daemon = True
tick_thread.start()

number_server_thread = NumberServerThread(csprng)
number_server_thread.daemon = True
number_server_thread.start()

while True:
  time.sleep(1)
